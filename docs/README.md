# Quartz Hardware Description Language (QuartzHDL)

Quartz is a strongly typed hardware description language with Rust-like syntax that compiles to SystemVerilog.  
As it is still work-in-progress some planned features are not or only partially implemented.  
Quartz is designed for FPGA synthesis only and as such has only limited support for tri-state logic.

## Inbuilt types

On its core Quartz only has one inbuilt type, `bits<N>`, which is a vector of N bits.  
A bit in Quartz must always be in a valid logic state, Z and X as in Verilog are not valid states.

The inbuilt type names `bit` and `bool` are aliases for `bits<1>`, and the literals `true` and `false` are aliases for `1` and `0` respectively.

## Variables

Variables in Quartz can be of two kinds:
- `sig`: a wire connection that carries a signal
- `reg`: a memory cell that stores a state

```rust
sig a: bits<8>;
reg b: bits<16>;
```

### Ports

Ports are a special kind of variable that also defines a direction, either `in` or `out`. Combining `in` with `reg` is not legal.  
Note that tri-state port declarations are not supported in Quartz.

```rust
in sig a: bit,
out sig b: bit,
out reg c: bit,

// illegal
in reg d: bit,
```

## Arrays

Quartz supports arrays to define multiple values of the same type at once.  
Arrays are often used to define memory blocks but are also supported with signals, ports, and in structures.

```rust
reg mem: [bits<8>; 1024];
```

Array items are accessed using the postfix `[]` syntax.

## Structures

Quartz allows the declaration of structs to group multiple values together.  
Structs consist of one or more fields where each can have a different type (including other structures and arrays).

```rust
struct S1 {
    a: bits<1>,
    b: bits<2>,
}

struct S2 {
    c: bits<3>,
    d: S1,
}
```

Struct fields are accessed using the `.` syntax.

## Modules

Like Verilog, Quartz divides digital designs into modules.  
A module consists of ports, variables, sub-modules and processes.

```rust
mod M (
    // port list
) {
    // body: contains variables, sub-modules and processes
}
```

### Sub-modules

To instantiate a sub-module use the `let` keyword:
```rust
let sub: SubModule;
```

### Processes

Processes define the behaviour of the module. There are two kinds of processes in Quartz:
- `comb`: a combinatorial process which is executed continuously
- `proc`: a sequential process which is executed on the edges of clock signals

To specify which clock edges a sequential process is sensitive to, use a comma separated list of `rising(clk)` or `falling(clk)`.

```rust
comb {
    // body
}

proc rising(clk) {
    // body
}
```

Only `sig` variables can be assigned in `comb` processes, and only `reg` variables can be assigned in `proc` processes.

## Constant evaluation

Quartz has a constant evaluation context that operates on signed 64 bit integers only.  
Constants can be defined inside and outside of modules, but not inside processes.  
If a constant is defined inside a module, it is only accessible inside that module and its port declarations.

```rust
const C = 10;
```

### Functions

Functions can be defined to perform more complex computations on constants.  
All functions must return a value.

```rust
fn clog2(n_bits) {
    n_bits -= 1;
    let log = 0;
    while n_bits != 0 {
        n_bits >>= 1;
        log += 1;
    }
    log
}
```

### Generic constants

Modules in Quatz can be generic over constants. Generic constants behave like constants defined inside the module.

```rust
mod M<N> (
    in sig data: bits<N>,
) {
    // ...
}
```

## Top module

Every design in Quartz must define exactly one top module.  
This module does not define a port list but instead connects to FPGA pins though special inbuilt sub-modules.

```rust
top mod Top {
    // access the pin with pi.d_in
    let pi: InPort<1>;

    // access the pin with po.d_out
    let po: OutPort<1>;

    // access the pin with pio.d_in and pio.d_out, and swap direction with pio.oe (1 = output)
    let pio: InOutPort<1>;
}
```

## Extern module

Extern modules are modules without body. They offer a way to interface with existing Verilog modules.  
The actual Verilog implementation of the module must be supplied to the synthesis software together with the code generated by Quartz.

```rust
extern mod Pll (
    in sig clk25: bit,

    out sig clk200: bit,
    out sig clk120: bit,
    out sig clk40: bit,
    out sig locked: bool,
);
```

## Attributes

Quartz supports attributes on modules, ports and variables. Attributes are converted into equivalent Verilog attributes.

```rust
#[attr1, attr2(param)]
sig a: bits<16>;
```
